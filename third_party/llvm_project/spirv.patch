diff --git a/llvm/include/llvm/InitializePasses.h b/llvm/include/llvm/InitializePasses.h
index 5c531ea89cc6..594618fe5414 100644
--- a/llvm/include/llvm/InitializePasses.h
+++ b/llvm/include/llvm/InitializePasses.h
@@ -99,6 +99,7 @@ void initializeCrossDSOCFIPass(PassRegistry&);
 void initializeCycleInfoWrapperPassPass(PassRegistry &);
 void initializeDAEPass(PassRegistry&);
 void initializeDAHPass(PassRegistry&);
+void initializeDAESYCLPass(PassRegistry&);
 void initializeDCELegacyPassPass(PassRegistry&);
 void initializeDFAJumpThreadingLegacyPassPass(PassRegistry &);
 void initializeDSELegacyPassPass(PassRegistry&);
@@ -372,6 +373,9 @@ void initializeStripGCRelocatesLegacyPass(PassRegistry &);
 void initializeStripNonLineTableDebugLegacyPassPass(PassRegistry &);
 void initializeStripSymbolsPass(PassRegistry&);
 void initializeStructurizeCFGLegacyPassPass(PassRegistry &);
+void initializeSYCLLowerWGScopeLegacyPassPass(PassRegistry &);
+void initializeSYCLMutatePrintfAddrspaceLegacyPassPass(PassRegistry &);
+void initializeSYCLLowerWGLocalMemoryLegacyPass(PassRegistry &);
 void initializeTailCallElimPass(PassRegistry&);
 void initializeTailDuplicatePass(PassRegistry&);
 void initializeTargetLibraryInfoWrapperPassPass(PassRegistry&);
diff --git a/llvm/include/llvm/SYCLLowerIR/LocalAccessorToSharedMemory.h b/llvm/include/llvm/SYCLLowerIR/LocalAccessorToSharedMemory.h
new file mode 100644
index 000000000000..9dfd6dc18926
--- /dev/null
+++ b/llvm/include/llvm/SYCLLowerIR/LocalAccessorToSharedMemory.h
@@ -0,0 +1,69 @@
+//===- LocalAccessorToSharedMemory.cpp - Local Accessor Support for CUDA --===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===----------------------------------------------------------------------===//
+
+#ifndef LLVM_SYCL_LOCALACCESSORTOSHAREDMEMORY_H
+#define LLVM_SYCL_LOCALACCESSORTOSHAREDMEMORY_H
+
+#include "llvm/IR/Module.h"
+#include "llvm/IR/PassManager.h"
+#include "llvm/SYCLLowerIR/TargetHelpers.h"
+
+namespace llvm {
+
+class ModulePass;
+class PassRegistry;
+
+/// This pass operates on SYCL kernels. It modifies kernel entry points which
+/// take pointers to shared memory and alters them to take offsets into shared
+/// memory (represented by a symbol in the shared address space). The SYCL
+/// runtime is expected to provide offsets rather than pointers to these
+/// functions.
+class LocalAccessorToSharedMemoryPass
+    : public PassInfoMixin<LocalAccessorToSharedMemoryPass> {
+private:
+  using KernelPayload = TargetHelpers::KernelPayload;
+  using ArchType = TargetHelpers::ArchType;
+
+public:
+  explicit LocalAccessorToSharedMemoryPass() {}
+
+  PreservedAnalyses run(Module &M, ModuleAnalysisManager &);
+  static StringRef getPassName() {
+    return "SYCL Local Accessor to Shared Memory";
+  }
+
+private:
+  /// This function replaces pointers to shared memory with offsets to a global
+  /// symbol in shared memory.
+  /// It alters the signature of the kernel (pointer vs offset value) as well
+  /// as the access (dereferencing the argument pointer vs GEP to the global
+  /// symbol).
+  ///
+  /// \param F The kernel to be processed.
+  ///
+  /// \returns A new function with global symbol accesses.
+  Function *processKernel(Module &M, Function *F);
+
+  /// Update kernel metadata to reflect the change in the signature.
+  ///
+  /// \param A map of original kernels to the modified ones.
+  void postProcessKernels(
+      SmallVectorImpl<std::pair<Function *, KernelPayload>> &NewToOldKernels);
+
+private:
+  /// The value for NVVM's ADDRESS_SPACE_SHARED and AMD's LOCAL_ADDRESS happen
+  /// to be 3.
+  const unsigned SharedASValue = 3;
+};
+
+ModulePass *createLocalAccessorToSharedMemoryPassLegacy();
+void initializeLocalAccessorToSharedMemoryLegacyPass(PassRegistry &);
+
+} // end namespace llvm
+
+#endif
diff --git a/llvm/include/llvm/SYCLLowerIR/LowerWGLocalMemory.h b/llvm/include/llvm/SYCLLowerIR/LowerWGLocalMemory.h
new file mode 100644
index 000000000000..cdb8e6dff021
--- /dev/null
+++ b/llvm/include/llvm/SYCLLowerIR/LowerWGLocalMemory.h
@@ -0,0 +1,52 @@
+//===-- LowerWGLocalMemory.h - SYCL kernel local memory allocation pass ---===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===----------------------------------------------------------------------===//
+// This pass does the following for each allocate call to
+// __sycl_allocateLocalMemory(Size, Alignment) function at the kernel scope:
+// - inserts a global (in scope of a program) byte array of Size bytes with
+//   specified alignment in work group local address space.
+// - replaces allocate call with access to this memory.
+//
+// For example, the following IR code in a kernel function:
+//   define spir_kernel void @KernelA() {
+//     %0 = call spir_func i8 addrspace(3)* @__sycl_allocateLocalMemory(
+//         i64 128, i64 4)
+//     %1 = bitcast i8 addrspace(3)* %0 to i32 addrspace(3)*
+//   }
+//
+// is translated to the following:
+//   @WGLocalMem = internal addrspace(3) global [128 x i8] undef, align 4
+//   define spir_kernel void @KernelA() {
+//     %0 = bitcast i8 addrspace(3)* getelementptr inbounds (
+//         [128 x i8], [128 x i8] addrspace(3)* @WGLocalMem, i32 0, i32 0)
+//         to i32 addrspace(3)*
+//   }
+//===----------------------------------------------------------------------===//
+
+#ifndef LLVM_SYCLLOWERIR_LOWERWGLOCALMEMORY_H
+#define LLVM_SYCLLOWERIR_LOWERWGLOCALMEMORY_H
+
+#include "llvm/IR/Module.h"
+#include "llvm/IR/PassManager.h"
+
+namespace llvm {
+
+class ModulePass;
+class PassRegistry;
+
+class SYCLLowerWGLocalMemoryPass
+    : public PassInfoMixin<SYCLLowerWGLocalMemoryPass> {
+public:
+  PreservedAnalyses run(Module &M, ModuleAnalysisManager &);
+};
+
+ModulePass *createSYCLLowerWGLocalMemoryLegacyPass();
+void initializeSYCLLowerWGLocalMemoryLegacyPass(PassRegistry &);
+
+} // namespace llvm
+
+#endif // LLVM_SYCLLOWERIR_LOWERWGLOCALMEMORY_H
diff --git a/llvm/include/llvm/SYCLLowerIR/LowerWGScope.h b/llvm/include/llvm/SYCLLowerIR/LowerWGScope.h
new file mode 100644
index 000000000000..454159249edf
--- /dev/null
+++ b/llvm/include/llvm/SYCLLowerIR/LowerWGScope.h
@@ -0,0 +1,33 @@
+//===-- LowerWGScope.h - lower work group-scope code ----------------------===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===----------------------------------------------------------------------===//
+//
+//
+//===----------------------------------------------------------------------===//
+
+#ifndef CLANG_LIB_CODEGEN_SYCLLOWERIR_LOWERWGCODE_H
+#define CLANG_LIB_CODEGEN_SYCLLOWERIR_LOWERWGCODE_H
+
+#include "llvm/IR/Function.h"
+#include "llvm/IR/PassManager.h"
+
+namespace llvm {
+
+class FunctionPass;
+
+/// SPIRV target specific pass to transform work group-scope code to match SIMT
+/// execution model semantics - this code must be executed once per work group.
+class SYCLLowerWGScopePass : public PassInfoMixin<SYCLLowerWGScopePass> {
+public:
+  PreservedAnalyses run(Function &F, FunctionAnalysisManager &);
+};
+
+FunctionPass *createSYCLLowerWGScopePass();
+
+} // namespace llvm
+
+#endif // CLANG_LIB_CODEGEN_SYCLLOWERIR_LOWERWGCODE_H
diff --git a/llvm/include/llvm/SYCLLowerIR/TargetHelpers.h b/llvm/include/llvm/SYCLLowerIR/TargetHelpers.h
new file mode 100644
index 000000000000..b2b383237a70
--- /dev/null
+++ b/llvm/include/llvm/SYCLLowerIR/TargetHelpers.h
@@ -0,0 +1,43 @@
+//===------------ TargetHelpers.h - Helpers for SYCL kernels ------------- ===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===----------------------------------------------------------------------===//
+//
+// Helper functions for processing SYCL kernels.
+//
+//===----------------------------------------------------------------------===//
+
+#ifndef LLVM_SYCL_SYCL_LOWER_IR_TARGET_HELPERS_H
+#define LLVM_SYCL_SYCL_LOWER_IR_TARGET_HELPERS_H
+
+#include "llvm/ADT/SmallVector.h"
+#include "llvm/IR/Function.h"
+#include "llvm/IR/Module.h"
+
+using namespace llvm;
+
+namespace llvm {
+namespace TargetHelpers {
+
+enum class ArchType { Cuda, AMDHSA, Unsupported };
+
+struct KernelPayload {
+  KernelPayload(Function *Kernel, MDNode *MD = nullptr);
+  Function *Kernel;
+  MDNode *MD;
+};
+
+ArchType getArchType(const Module &M);
+
+std::string getAnnotationString(ArchType AT);
+
+void populateKernels(Module &M, SmallVectorImpl<KernelPayload> &Kernels,
+                     TargetHelpers::ArchType AT);
+
+} // end namespace TargetHelpers
+} // end namespace llvm
+
+#endif
diff --git a/llvm/lib/CMakeLists.txt b/llvm/lib/CMakeLists.txt
index 283baa6090eb..ef0bb7544522 100644
--- a/llvm/lib/CMakeLists.txt
+++ b/llvm/lib/CMakeLists.txt
@@ -37,6 +37,7 @@ add_subdirectory(AsmParser)
 add_subdirectory(LineEditor)
 add_subdirectory(ProfileData)
 add_subdirectory(Passes)
+add_subdirectory(SYCLLowerIR)
 add_subdirectory(TargetParser)
 add_subdirectory(TextAPI)
 add_subdirectory(ToolDrivers)
diff --git a/llvm/lib/Passes/PassBuilderPipelines.cpp b/llvm/lib/Passes/PassBuilderPipelines.cpp
index 6cc66a0cb132..29c3431f84eb 100644
--- a/llvm/lib/Passes/PassBuilderPipelines.cpp
+++ b/llvm/lib/Passes/PassBuilderPipelines.cpp
@@ -192,6 +192,10 @@ static cl::opt<bool> EnableGlobalAnalyses(
     "enable-global-analyses", cl::init(true), cl::Hidden,
     cl::desc("Enable inter-procedural analyses"));
 
+static cl::opt<bool>
+    SYCLOptimizationMode("sycl-opt", cl::init(false), cl::Hidden,
+                         cl::desc("Enable SYCL optimization mode."));
+
 static cl::opt<bool>
     RunPartialInlining("enable-partial-inlining", cl::init(false), cl::Hidden,
                        cl::desc("Run Partial inlinining pass"));
@@ -354,6 +358,7 @@ PassBuilder::buildO1FunctionSimplificationPipeline(OptimizationLevel Level,
   // Form canonically associated expression trees, and simplify the trees using
   // basic mathematical properties. For example, this will form (nearly)
   // minimal multiplication trees.
+  if (!SYCLOptimizationMode) {
   FPM.addPass(ReassociatePass());
 
   // Add the primary loop simplification pipeline.
@@ -431,7 +436,7 @@ PassBuilder::buildO1FunctionSimplificationPipeline(OptimizationLevel Level,
   FPM.addPass(createFunctionToLoopPassAdaptor(std::move(LPM2),
                                               /*UseMemorySSA=*/false,
                                               /*UseBlockFrequencyInfo=*/false));
-
+  }
   // Delete small array after loop unroll.
   FPM.addPass(SROAPass(SROAOptions::ModifyCFG));
 
@@ -539,6 +544,7 @@ PassBuilder::buildFunctionSimplificationPipeline(OptimizationLevel Level,
   // Form canonically associated expression trees, and simplify the trees using
   // basic mathematical properties. For example, this will form (nearly)
   // minimal multiplication trees.
+  if (!SYCLOptimizationMode) {
   FPM.addPass(ReassociatePass());
 
   // Add the primary loop simplification pipeline.
@@ -620,7 +626,7 @@ PassBuilder::buildFunctionSimplificationPipeline(OptimizationLevel Level,
   FPM.addPass(createFunctionToLoopPassAdaptor(std::move(LPM2),
                                               /*UseMemorySSA=*/false,
                                               /*UseBlockFrequencyInfo=*/false));
-
+  }
   // Delete small array after loop unroll.
   FPM.addPass(SROAPass(SROAOptions::ModifyCFG));
 
@@ -677,6 +683,9 @@ PassBuilder::buildFunctionSimplificationPipeline(OptimizationLevel Level,
   for (auto &C : ScalarOptimizerLateEPCallbacks)
     C(FPM, Level);
 
+  if (SYCLOptimizationMode)
+    FPM.addPass(SimplifyCFGPass());
+  else
   FPM.addPass(SimplifyCFGPass(SimplifyCFGOptions()
                                   .convertSwitchRangeToICmp(true)
                                   .hoistCommonInsts(true)
@@ -1320,6 +1329,7 @@ PassBuilder::buildModuleOptimizationPipeline(OptimizationLevel Level,
   for (auto &C : VectorizerStartEPCallbacks)
     C(OptimizePM, Level);
 
+  if (!SYCLOptimizationMode) {
   LoopPassManager LPM;
   // First rotate loops that may have been un-rotated by prior passes.
   // Disable header duplication at -Oz.
@@ -1343,7 +1353,7 @@ PassBuilder::buildModuleOptimizationPipeline(OptimizationLevel Level,
   OptimizePM.addPass(InjectTLIMappings());
 
   addVectorPasses(Level, OptimizePM, /* IsFullLTO */ false);
-
+  }
   // LoopSink pass sinks instructions hoisted by LICM, which serves as a
   // canonicalization pass that enables other optimizations. As a result,
   // LoopSink pass needs to be a very late IR pass to avoid undoing LICM
